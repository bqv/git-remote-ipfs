#!/usr/bin/env node

/**
 * Remote helper programs are invoked with one or (optionally) two arguments.
 * The first argument specifies a remote repository as in Git; it is either the name of a configured remote or a URL.
 * The second argument specifies a URL; it is usually of the form <transport>://<address>.
 * https://git-scm.com/docs/gitremote-helpers#_invocation
 */
if(process.argv.length < 2) {
  console.error('Usage: git-remote-igis remote-name url')
  process.exit(-10)
}

const readline = require('readline')
const Git = require('nodegit')
//const IPFS = require('ipfs')
const IPFSProxy = require('ipfs-http-client')
const all = require('it-all')
const toBuffer = require('it-to-buffer')
const OrbitDB = require('orbit-db')
const levelup = require('levelup')
const leveldown = require('leveldown')
const { Console } = require('console');
const fs = require('fs')
const { v1:uuidv1 } = require('uuid');
const crypto = require('crypto');
const { composeAPI } = require('@iota/core')
const { asciiToTrytes, trytesToAscii } = require('@iota/converter')
const { channelRoot, createChannel, createMessage, parseMessage, mamAttach, mamFetch, mamFetchAll } = require('@iota/mam.js');

const EMPTY_REPO_CID = 'QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn'
const DEBUG = !!process.env.IGIS_DEBUG

const console = new Console(process.stderr)

const objForSig = (sig) => ({
  name: sig.name(), email: sig.email(),
  time: sig.when().time(), offset: sig.when().offset()
})

if(!process.env.GIT_DIR) {
  process.stderr.write('$GIT_DIR must be defined')
  process.exit(-9)
}

const genSeed = (length = 81) => {
  const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ9'
  let seed = ''
  do {
    const bytes = crypto.randomBytes(1)
    if(bytes[0] < 243) { // 243 % 27 == 0
      seed += alphabet[bytes[0] % alphabet.length]
    }
  } while(seed.length < length)
  return seed
}

;(async () => {
  const dataDir = `${process.env.GIT_DIR}/remote-igis`
  const cacheDir = `${dataDir}/cache`
  const configDir = `${dataDir}/config`
  const repo = await Git.Repository.open(process.env.GIT_DIR)
  const odb = await repo.odb()
  const ipfs = IPFSProxy()
  fs.mkdirSync(dataDir, { recursive: true })
  const configDB = levelup(leveldown(configDir))
  const config = {
    get: async (key) => {
      try {
        return await configDB.get(key)
      } catch(err) { /* Not found */ }
    },
    put: async (key, val) => {
      await configDB.put(key, val)
      return val
    },
  }
  const cacheDB = levelup(leveldown(cacheDir))  
  const cache = {
    get: async (key) => {
      if(!process.env.IGIS_NO_CACHE) {
        try {
          return await cacheDB.get(key)
        } catch(err) { /* Not found */ }
      }
    },
    put: cacheDB.put.bind(cacheDB),
  }

  const oidInODB = async (oid) => {
    try {
      return await odb.existsPrefix(oid, oid.length)
    } catch(err) {
      return false
    }
  }

  const treeFor = async (root, modesCID) => {
    DEBUG && console.debug('treeFor()', root.toString())
    const list = await all(ipfs.ls(root.toString()))
    const tb = await Git.Treebuilder.create(repo, null)
    const modes = (await ipfs.dag.get(modesCID)).value

    await Promise.all(list.map(async ({ name, cid, type }) => {
      if(type === 'dir') {
        let oid = await cache.get(cid)
        if(!oid || !(await oidInODB(oid.toString()))) {
          oid = await treeFor(cid, modes[name])
          await cache.put(cid, oid)
        }
        tb.insert(name, oid.toString(), Git.TreeEntry.FILEMODE.TREE)
      } else {
        let oid = await cache.get(cid)
        if(!oid || !(await oidInODB(oid.toString()))) {
          const buffer = await toBuffer(ipfs.cat(cid))
          oid = await Git.Blob.createFromBuffer(repo, buffer, buffer.length)
          await cache.put(cid, oid) // if not awaited, the cache can close before this executes
        }
        tb.insert(name, oid.toString(), modes[name])
      }
    }))
    .catch(console.error)

    return tb.write()
  }

  const commitFor = async (cid) => {
    DEBUG && console.debug('commitFor()', cid)
    const root = (await ipfs.dag.get(cid)).value
    const {
      authorSig, committerSig, encoding, message, oid,
      tree:treeCID, modes, parents:parentCIDs, signature,
    } = root
    const treeOID = await treeFor(treeCID, modes)
    const tree = await Git.Tree.lookup(repo, treeOID)
    const parents = await Promise.all(parentCIDs.map(
      async c => await Git.Commit.lookup(repo, await commitFor(c))
    ))
    const parent_count = parents.length
    const author = Git.Signature.create(authorSig.name, authorSig.email, authorSig.time, authorSig.offset)
    const committer = Git.Signature.create(committerSig.name, committerSig.email, committerSig.time, committerSig.offset)

    let commit
    if(signature) {
      const buffer = await Git.Commit.createBuffer(
        repo, author, committer, encoding, message, tree, parent_count, parents
      )
      commit = await Git.Commit.createWithSignature(repo, buffer.toString(), signature, 'gpgsig')
    } else {
      const buffer = await Git.Commit.createBuffer(
        repo, author, committer, encoding, message, tree, parent_count, parents
      )
      commit = await Git.Commit.create(
        repo, null, author, committer, encoding, message, tree, parent_count, parents
      )
    }
    process.stderr.write(`Commit: ${commit}/${oid} (${cid})\n`)
    process.stderr.write(`Tree OID: ${treeOID} (${treeCID})\n`)
    return commit
  }

  const addTree = async (tree, base = EMPTY_REPO_CID) => {
    DEBUG && console.debug('addTree()', tree.id().toString())
    var modes = {}
    for(const e of (await tree.entries())) {
      let cid = await cache.get(e.oid())
      if(e.isTree()) {
        let childModes = await cache.get(`modes:${e.oid()}`)
        if(childModes) childModes = new IPFSProxy.CID(childModes.toString())
        DEBUG && console.debug('addTree() recursing', childModes)
        if(!cid || !childModes) {
          DEBUG && console.debug('Cache Miss', e.oid().toString())
          ;[cid, childModes] = await addTree(await e.getTree())
          await cache.put(e.oid().toString(), cid)
          await cache.put(`modes:${e.oid().toString()}`, childModes.toString())
          console.debug('CID', cid, childModes)
        }
        modes[e.name()] = childModes
      } else if(e.filemode().toString(8)[0] === '1') { // e.isBlob() is false for links
        if(!cid) {
          const content = (await e.getBlob()).content()
          const progress = (len) => process.stderr.write(`len:${len}\n`)

          DEBUG && console.debug('Adding', e.name())

          cid = (await all(ipfs.add({ content: content, progress: progress, pin: true })))[0].cid
          await cache.put(e.oid(), cid)
        }
        modes[e.name()] = e.filemode()
      } else {
        console.warn(`Neither Blob nor Tree TreeEntry: ${e.oid()} (${e.filemode().toString(8)})`)
        continue
      }
      DEBUG && console.debug('Patching', e.name(), cid.toString())
      base = await ipfs.object.patch.addLink(
        base, { name: e.name(), cid: cid }, { pin: true }
      )
  }

    return [base, await ipfs.dag.put(modes, { pin: true })]
  }

  let oidMgr = {
    resolvers: {},
    convert: (oid) => {
      if(!oidMgr.resolvers[oid]) { // new
        addCommit(oid)
        oidMgr.resolvers[oid] = []
      }
      const promise = new Promise((res, rej) => {
        oidMgr.resolvers[oid].push(res)
      })
      return promise
    },
    cidFound: (oid, cid) => {
      if(oidMgr.resolvers[oid]) {
        while(oidMgr.resolvers[oid].length > 0) {
          oidMgr.resolvers[oid].pop().call(this, cid)
        }
      }
    }
  }

  const addCommit = async (oid) => {
    DEBUG && console.debug('addCommit()', oid.toString())
    process.stderr.write(`mit:${oid}: `)
    let cid = await cache.get(oid)
    if(cid) {
      cid = new IPFSProxy.CID(cid.toString())
      process.stderr.write(`cache:${cid}\n`)
    } else {
      const head = await Git.Commit.lookup(repo, oid)
      const [tree, modes] = await addTree(await head.getTree())
      process.stderr.write(`tree:${tree}\n`) // \r\x1b[A
      const parents = await Promise.all((await head.parents()).map(p => oidMgr.convert(p)))
      const obj = {
        authorSig: objForSig(head.author()), committerSig: objForSig(head.committer()),
        encoding: head.messageEncoding(), message: head.message(),
        parents: parents, tree: new IPFSProxy.CID(tree), modes: modes,
        oid: oid.toString(),
      }
      try {
        obj.signature = await head.headerField('gpgsig')
      } catch(err) { /* No signature */ }
      cid = await ipfs.dag.put(obj, { pin: true })
      await cache.put(oid.toString(), cid)
    }
    oidMgr.cidFound(oid, cid)
    return cid
  }

  const addTag = async (oid, name) => {
    let obj
    try {
      process.stderr.write(`tag:${oid}: `)
      const tag = await Git.Tag.lookup(repo, oid)
      const commit = await addCommit(tag.targetId())

      obj = {
        commit: commit, taggerSig: objForSig(tag.tagger()),
        name: name, message: tag.message(), type: 'annotated',
      }
    } catch(err) { // Lightweight tags return a commit instead of a tag
      const commit = await addCommit(oid)
      obj = {
        name: name, commit: commit, type: 'lightweight',
      }
    }
    return await ipfs.dag.put(obj, { pin: true })
  }

  const serializeRefs = async (root, path = 'refs') => {
    await Promise.all(Object.entries(root).map(async ([name, obj]) => {
      if(obj instanceof IPFSProxy.CID || obj.codec == 'dag-cbor') {
        const commit = (await ipfs.dag.get(obj)).value
        DEBUG && console.debug(`> ${commit.oid} ${path}/${name}`)
        process.stdout.write(`${commit.oid} ${path}/${name}\n`)
      } else {
        await serializeRefs(obj, `${path}/${name}`)
      }
    }))
  }

  const doFetch = async (url) => {
    console.debug('url', url)
    for(const [hash, ref] of [...new Set(fetchRefs)]) {
      DEBUG && console.debug('doFetch()', `${process.argv[3]}/.git/${ref}`)
      const commit = await commitFor(`${process.argv[3]}/.git/${ref}`)
      try {
        await repo.createBranch(ref.replace(/^refs\/heads\//, ''), commit)
        console.debug(`Created Branch: ${ref.replace(/^refs\/heads\//, '')}`)
      } catch(err) { /* exists */}
    }
    await repo.setHead((await ipfs.dag.get(`${process.argv[3]}/.git/HEAD`)).value)
  }

  const doPush = async () => {
    const tag = '99IGIS99REPOSITORY99'
    const depth = 3
    const mvw = 9 /* devnet */ // 14 /* mainnet */
    const mode = 'public'
    let base, vfs = {}

    try {
      if(process.argv[3]) {
        vfs = (await ipfs.dag.get(`${process.argv[3]}/.git/`)).value
      }
    } catch(err) {
      console.error(err)
    }

    const seed = ((await config.get('key')) || await config.put('key', genSeed())).toString()
    let channelState = vfs.channel ? {...vfs.channel, seed} : createChannel(seed, 2, mode)
    console.debug('CHANSTATE', channelState)
    const IOTA = composeAPI({ provider: 'https://altnodes.devnet.iota.org:443' })
    //const IOTA = composeAPI({ provider: 'https://nodes.thetangle.org:443' })

    const maxSteps = 5
    console.debug('LR', channelState.nextRoot, channelRoot(channelState))
    let last = { nextRoot: channelState.nextRoot || channelRoot(channelState) }
    let steps
    do {
      console.debug('Walking the MAM tree to find the root', last.nextRoot)
      steps = await mamFetchAll(IOTA, last.nextRoot, mode, undefined, maxSteps)
      steps.forEach((s) => console.debug(s.nextRoot, trytesToAscii(s.message)))
      if(steps.length > 0 || !last.message) {
        last = steps.slice(-1)[0]
      }
    } while(steps.length === maxSteps)

    try {
      if(last) {
        console.debug('Loading From', last.message, trytesToAscii(last.message))
        vfs = (await ipfs.dag.get(`${trytesToAscii(last.message)}/.git/`)).value
        channelState = vfs.channel ? {...vfs.channel, seed} : channelState
        channelState.start++
        channelState.nextRoot = last.nextRoot
      }
    } catch(err) {
      console.error(err)
    }

    // Unset so it will be set to the commit that was just pushed
    vfs.HEAD = undefined

    while(pushRefs.length > 0) {
      const [src, dst] = pushRefs.shift()

      DEBUG && console.debug('doPush', src, dst)

      try {
        const oid = await Git.Reference.nameToId(repo, src)
        const isTag = dst.split('/')[1] === 'tags'
        DEBUG && console.debug('Starting w/ OID', oid.toString(), `(${src})`)
        const cid = await (isTag
          ? addTag(oid, dst.split('/').slice(2).join('/'))
          : addCommit(oid)
        )

        const parts = dst.split('/')
        const last = parts.slice(0, parts.length - 1).reduce((obj, step) => {
          return obj[step] = obj[step] || {}
        }, vfs)
        last[parts.slice(-1)[0]] = cid

        base = base || ((await ipfs.dag.get(`${cid}${isTag ? '/commit' : ''}`)).value).tree
        vfs.HEAD = vfs.HEAD || dst

        DEBUG && console.debug(`> ok ${dst}`)
        process.stdout.write(`ok ${dst}\n`)
      } catch(e) {
        console.error(e)
      }
    }

    vfs.uuid = vfs.uuid || uuidv1()

    const channelless = await ipfs.object.patch.addLink(
      base,
      { name: '.git', cid: await ipfs.dag.put(vfs) },
      { create: true }
    )

    // check if the repo sans channel info has been uploaded already
    let cid = await cache.get(channelless.toString())
    if(!cid) {
      vfs.channel = {...channelState}
      delete vfs.channel.seed
      cid = await ipfs.object.patch.addLink(
        base,
        { name: '.git', cid: await ipfs.dag.put(vfs, { pin: true }) },
        { create: true, pin: true }
      )
      await cache.put(channelless.toString(), cid.toString())
      // alters channelState adding nextRoot
      const mamMessage = createMessage(channelState, asciiToTrytes(base.toString()))
      await mamAttach(IOTA, mamMessage, depth, mvw, tag);
    }

    process.stderr.write(`igis::${cid.toString()}\n`)
  }

  const rl = readline.createInterface({
    input: process.stdin, output: process.stdout, terminal: false,
  })
  const pushRefs = []
  const fetchRefs = []
  rl.on('line', async (line) => {
    DEBUG && console.debug('<', line)

    if(line === 'capabilities') {
      for(let option of ['options', 'push', 'fetch']) {
        DEBUG && console.debug(`> ${option}`)
        process.stdout.write(`${option}\n`)
      }
      process.stdout.write("\n")
    } else if(line.startsWith('list')) {
      if(process.argv[3]) {
        const config = (await ipfs.dag.get(`${process.argv[3]}/.git/`)).value
        if(config.HEAD) {
          DEBUG && console.debug(`> @${config.HEAD} HEAD`)
          process.stdout.write(`@${config.HEAD} HEAD\n`)
        }
        await serializeRefs(config.refs)
      }
      process.stdout.write("\n")
    } else if(line.startsWith('push')) {
      try {
        const ref = line.replace(/^push\s+/, '')
        pushRefs.push(ref.split(':'))
      } catch(err) {
        console.error(`Can't Push: Invalid Refs: '${line}' (${err})\n`)
        process.exit(-12)
      }
    } else if(line.startsWith('fetch')) {
      const ref = line.replace(/^fetch\s+/, '')
      fetchRefs.push(ref.split(' '))
    } else if(line === '') { // a blank line follows a set of push/fetch commands
      const url = process.argv[2]
      if(pushRefs.length > 0) { 
        await doPush(url)
        DEBUG && console.debug('>')
        process.stdout.write("\n")
      }
      if(fetchRefs.length > 0){ 
        await doFetch(url)
        DEBUG && console.debug('>')
        try {
          process.stdout.write("\n")
        } catch(err) {
           // this raises EPIPE for a closed pipe, but git doesn't exit otherwise
        }
      }
    } else {
      console.debug(line)
    }
  })
})()