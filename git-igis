#!/usr/bin/env node

console.error = console.debug = console.warn = (
  (msg) => process.stderr.write(`${msg}\n`)
)

const yargs = require('yargs');
const IPFSProxy = require('ipfs-http-client')
const OrbitDB = require('orbit-db')
var levelup = require('levelup')
var leveldown = require('leveldown')

;(async () => {
  const cacheDir = `${__dirname}/.git/remote-igis`
  const argv = (
    yargs
    .command('hash-cache:clear', 'Remove all entries from OID cache')
    .command('hash-cache:dump', 'Display all entries from OID cache')
    .help().alias('help', 'h')
    .argv
  )

  if(argv._.includes('hash-cache:clear')) {
    const ipfs = IPFSProxy()
    const orbitdb = await OrbitDB.createInstance(ipfs, { directory: cacheDir })
    const dbOptions = { accessController: { write: [orbitdb.identity.id] }}
    const cache = await orbitdb.kvstore('igis:hash-cache', dbOptions)
    cache.drop()
  }

  if(argv._.includes('ls')) {
    const ipfs = IPFSProxy()
    const orbitdb = await OrbitDB.createInstance(ipfs, { directory: cacheDir })
    const dbOptions = { accessController: { write: [orbitdb.identity.id] } }
    const refs = await orbitdb.kvstore('igis:revs', dbOptions)
    console.log(`Reading From: ${refs.address}`)
    await Promise.all(Object.entries(refs.index).map(async ([ref, cid]) => {
      console.log('REF', ref, cid)
    }))
  }

  if(argv._.includes('hash-cache:dump')) {
    const cache = levelup(leveldown(cacheDir))
    await new Promise((resolve, reject) => (
      cache.createReadStream()
      .on('data', function (data) {
        process.stdout.write(`${data.key} :: ${data.value}\n`)
      })
      .on('error', reject)
      .on('close', resolve)
      .on('end', resolve)
    ))
    cache.close()
  }
})()